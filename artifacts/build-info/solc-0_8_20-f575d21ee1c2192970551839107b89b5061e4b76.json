{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-f575d21ee1c2192970551839107b89b5061e4b76",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/BondingCurveFactory.sol": "project/contracts/BondingCurveFactory.sol",
    "contracts/BondingCurvePool.sol": "project/contracts/BondingCurvePool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/BondingCurveFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IBondingCurveFactory} from \"./interfaces/IBondingCurveFactory.sol\";\nimport {IBondingCurvePool} from \"./interfaces/IBondingCurvePool.sol\";\nimport {ILaunchPadToken, ILaunchPadMintable} from \"./interfaces/ILaunchPadToken.sol\";\nimport {BondingCurvePool} from \"./BondingCurvePool.sol\";\nimport {LaunchPadToken} from \"./LaunchPadToken.sol\";\n\n/// @notice Minimal factory for scaffolding. Emits TokenCreated and keeps a registry.\ncontract BondingCurveFactory is IBondingCurveFactory {\n    address[] private _allTokens;\n    mapping(address => address) public poolOf; // token => pool\n\n    struct Meta { string iconURI; string projectURI; }\n    mapping(address => Meta) public metadataOf;\n\n    function createToken(\n        string calldata name,\n        string calldata symbol,\n        string calldata iconURI,\n        string calldata projectURI,\n        uint256 initialBuyAmountWei\n    ) external payable override returns (address token, address pool) {\n        require(bytes(name).length > 0 && bytes(symbol).length > 0, \"BAD_META\");\n        require(msg.value == initialBuyAmountWei, \"BAD_VALUE\");\n\n        // 1) Deploy token with temporary minter = this factory\n        LaunchPadToken t = new LaunchPadToken(name, symbol, address(this));\n\n        // 2) Deploy pool bound to token\n        BondingCurvePool p = new BondingCurvePool(address(t));\n\n        // 3) Set pool as minter so it can mint/burn on trades\n        ILaunchPadMintable(address(t)).setMinter(address(p));\n\n        // 4) If initial buy provided, forward to pool and buy for creator\n        if (initialBuyAmountWei > 0) {\n            (bool s, ) = address(p).call{value: initialBuyAmountWei}(abi.encodeWithSelector(\n                IBondingCurvePool.buy.selector,\n                msg.sender\n            ));\n            require(s, \"INIT_BUY_FAIL\");\n        }\n\n        // 5) Registry & event\n        token = address(t);\n        pool = address(p);\n        poolOf[token] = pool;\n        _allTokens.push(token);\n        metadataOf[token] = Meta({iconURI: iconURI, projectURI: projectURI});\n        emit TokenCreated(token, pool, name, symbol, iconURI, projectURI, msg.sender);\n    }\n\n    function getPool(address token) external view override returns (address pool) {\n        return poolOf[token];\n    }\n\n    function allTokens(uint256 index) external view override returns (address token) {\n        return _allTokens[index];\n    }\n\n    function allTokensLength() external view override returns (uint256 length) {\n        return _allTokens.length;\n    }\n}\n\n"
      },
      "project/contracts/BondingCurvePool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IBondingCurvePool} from \"./interfaces/IBondingCurvePool.sol\";\nimport {ILaunchPadToken, ILaunchPadMintable} from \"./interfaces/ILaunchPadToken.sol\";\n\n/// @notice Minimal pool with naive 1:1 Wei pricing for scaffolding.\n/// This is NOT production economics; replace with real bonding curve logic before deployment.\ncontract BondingCurvePool is IBondingCurvePool {\n    // Token bound to this pool\n    address public immutable token;\n    ILaunchPadToken private immutable tokenContract;\n    ILaunchPadMintable private immutable mintable;\n\n    // Actual reserves accounted by the pool (exclude virtual reserves)\n    uint256 private _hbarReserves;   // total HBAR held in the pool\n    uint256 private _tokenReserves;  // total tokens minted minus burned\n\n    // Virtual reserves and fee (in basis points). Owner is the factory.\n    address public owner;\n    uint256 public vHbar;   // virtual HBAR reserves (wei)\n    uint256 public vToken;  // virtual token reserves (token wei)\n    uint16  public feeBps;  // e.g., 10 = 0.10%\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    constructor(address token_) {\n        token = token_;\n        tokenContract = ILaunchPadToken(token_);\n        mintable = ILaunchPadMintable(token_);\n        owner = msg.sender;           // factory will be the owner\n        vHbar = 28.24 ether;          // tuned: ~28.24 HBAR virtual reserves\n        vToken = 1_000_000 ether;     // tuned: 1,000,000 token wei virtual reserves\n        feeBps = 10;                  // 0.10%\n    }\n\n    // Optional: allow factory (owner) to tune parameters after deployment\n    function setParams(uint256 newVHbar, uint256 newVToken, uint16 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 1000, \"FEE_TOO_HIGH\"); // <= 10%\n        vHbar = newVHbar;\n        vToken = newVToken;\n        feeBps = newFeeBps;\n    }\n\n    // --- views ---\n    function reserves() external view override returns (uint256 hbarReserves, uint256 tokenReserves) {\n        return (_hbarReserves, _tokenReserves);\n    }\n\n    function _k(uint256 H, uint256 T) internal view returns (uint256) {\n        unchecked {\n            return (H + vHbar) * (T + vToken);\n        }\n    }\n\n    function _applyInFee(uint256 amountIn) internal view returns (uint256) {\n        // effective input after fee\n        return (amountIn * (10_000 - feeBps)) / 10_000;\n    }\n\n    function getPriceForBuy(uint256 hbarInWei) external view override returns (uint256 tokensOut) {\n        if (hbarInWei == 0) return 0;\n        uint256 H = _hbarReserves;\n        uint256 T = _tokenReserves;\n        uint256 k = _k(H, T);\n        uint256 hInEff = (hbarInWei * (10_000 - feeBps)) / 10_000;\n        uint256 newHPlusV = H + hInEff + vHbar;\n        uint256 newTPlusV = k / newHPlusV;\n        uint256 curTPlusV = T + vToken;\n        if (newTPlusV >= curTPlusV) return 0;\n        tokensOut = curTPlusV - newTPlusV;\n    }\n\n    function getPriceForSell(uint256 tokensIn) external view override returns (uint256 hbarOutWei) {\n        if (tokensIn == 0) return 0;\n        uint256 H = _hbarReserves;\n        uint256 T = _tokenReserves;\n        uint256 k = _k(H, T);\n        uint256 tInEff = (tokensIn * (10_000 - feeBps)) / 10_000;\n        uint256 newTPlusV = T + tInEff + vToken;\n        uint256 newHPlusV = k / newTPlusV;\n        uint256 curHPlusV = H + vHbar;\n        if (newHPlusV >= curHPlusV) return 0;\n        hbarOutWei = curHPlusV - newHPlusV;\n    }\n\n    // --- trades ---\n    function buy(address to) external payable override returns (uint256 tokensOut) {\n        require(to != address(0), \"BAD_TO\");\n        uint256 hbarIn = msg.value;\n        require(hbarIn > 0, \"NO_INPUT\");\n\n        uint256 H = _hbarReserves;\n        uint256 T = _tokenReserves;\n        uint256 k = _k(H, T);\n        uint256 hInEff = _applyInFee(hbarIn);\n\n        uint256 newHPlusV = H + hInEff + vHbar;\n        uint256 newTPlusV = k / newHPlusV;\n        uint256 curTPlusV = T + vToken;\n        require(newTPlusV < curTPlusV, \"ZERO_OUT\");\n        tokensOut = curTPlusV - newTPlusV;\n        require(tokensOut > 0, \"ZERO_OUT\");\n\n        // mint to recipient; pool tracks reserves (collect full HBAR incl. fee)\n        mintable.mint(to, tokensOut);\n        _hbarReserves = H + hbarIn;          // add full input; fee stays in pool\n        _tokenReserves = T + tokensOut;\n\n        emit Bought(msg.sender, hbarIn, tokensOut);\n    }\n\n    function sell(address from, uint256 tokensIn) external override returns (uint256 hbarOutWei) {\n        require(from != address(0), \"BAD_FROM\");\n        require(tokensIn > 0, \"NO_INPUT\");\n\n        // pull tokens to pool; burn full tokensIn\n        bool ok = tokenContract.transferFrom(from, address(this), tokensIn);\n        require(ok, \"TRANSFER_FAIL\");\n\n        uint256 H = _hbarReserves;\n        uint256 T = _tokenReserves;\n        uint256 k = _k(H, T);\n        uint256 tInEff = _applyInFee(tokensIn);\n\n        uint256 newTPlusV = T + tInEff + vToken;\n        uint256 newHPlusV = k / newTPlusV;\n        uint256 curHPlusV = H + vHbar;\n        require(newHPlusV < curHPlusV, \"ZERO_OUT\");\n        hbarOutWei = curHPlusV - newHPlusV;\n        require(hbarOutWei > 0, \"ZERO_OUT\");\n        require(address(this).balance >= hbarOutWei && H >= hbarOutWei, \"INSUFFICIENT_HBAR\");\n\n        // burn seller tokens; update reserves then pay out HBAR\n        mintable.burn(address(this), tokensIn);\n        _tokenReserves = T - tokensIn;\n        _hbarReserves = H - hbarOutWei;\n\n        (bool s, ) = from.call{value: hbarOutWei}(\"\");\n        require(s, \"HBAR_SEND_FAIL\");\n\n        emit Sold(from, tokensIn, hbarOutWei);\n    }\n\n    // accept HBAR sent directly (e.g., self-destructs or direct sends)\n    receive() external payable {\n        _hbarReserves += msg.value;\n    }\n}\n\n"
      },
      "project/contracts/interfaces/IBondingCurveFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IBondingCurveFactory {\n    event TokenCreated(\n        address token,\n        address pool,\n        string name,\n        string symbol,\n        string iconURI,\n        string projectURI,\n        address indexed creator\n    );\n\n    function createToken(\n        string calldata name,\n        string calldata symbol,\n        string calldata iconURI,\n        string calldata projectURI,\n        uint256 initialBuyAmountWei\n    ) external payable returns (address token, address pool);\n\n    function getPool(address token) external view returns (address pool);\n\n    function allTokens(uint256 index) external view returns (address token);\n\n    function allTokensLength() external view returns (uint256 length);\n}\n\n"
      },
      "project/contracts/interfaces/IBondingCurvePool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IBondingCurvePool {\n    event Bought(address indexed buyer, uint256 hbarInWei, uint256 tokensOut);\n    event Sold(address indexed seller, uint256 tokensIn, uint256 hbarOutWei);\n\n    function token() external view returns (address);\n\n    function buy(address to) external payable returns (uint256 tokensOut);\n\n    function sell(address from, uint256 tokensIn) external returns (uint256 hbarOutWei);\n\n    function getPriceForBuy(uint256 hbarInWei) external view returns (uint256 tokensOut);\n\n    function getPriceForSell(uint256 tokensIn) external view returns (uint256 hbarOutWei);\n\n    function reserves() external view returns (uint256 hbarReserves, uint256 tokenReserves);\n}\n\n"
      },
      "project/contracts/interfaces/ILaunchPadToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ILaunchPadToken {\n    // ERC20 standard\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Optional mint/burn interface used by LaunchPad contracts (not exposed to UI ABI)\ninterface ILaunchPadMintable {\n    function mint(address to, uint256 amount) external;\n    function burn(address from, uint256 amount) external;\n    function setMinter(address newMinter) external;\n    function minter() external view returns (address);\n}\n\n"
      },
      "project/contracts/LaunchPadToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ILaunchPadToken, ILaunchPadMintable} from \"./interfaces/ILaunchPadToken.sol\";\n\n/// @title LaunchPadToken - minimal ERC20 with controlled mint/burn for bonding curve pools\ncontract LaunchPadToken is ILaunchPadToken, ILaunchPadMintable {\n    string private _name;\n    string private _symbol;\n    uint8 private constant _decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    address public owner;\n    address public override minter;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"ONLY_MINTER\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_, address initialMinter) {\n        _name = name_;\n        _symbol = symbol_;\n        owner = msg.sender;\n        minter = initialMinter;\n    }\n\n    // --- ERC20 view ---\n    function name() external view override returns (string memory) { return _name; }\n    function symbol() external view override returns (string memory) { return _symbol; }\n    function decimals() external pure override returns (uint8) { return _decimals; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function balanceOf(address account) external view override returns (uint256) { return _balances[account]; }\n    function allowance(address owner_, address spender) external view override returns (uint256) { return _allowances[owner_][spender]; }\n\n    // --- ERC20 write ---\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        uint256 cur = _allowances[from][msg.sender];\n        require(cur >= amount, \"INSUFFICIENT_ALLOWANCE\");\n        unchecked { _approve(from, msg.sender, cur - amount); }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    // --- admin ---\n    function setMinter(address newMinter) external override onlyOwner {\n        minter = newMinter;\n    }\n\n    // --- mint/burn ---\n    function mint(address to, uint256 amount) external override onlyMinter {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external override onlyMinter {\n        _burn(from, amount);\n    }\n\n    // --- internal helpers ---\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"ZERO_TO\");\n        uint256 bal = _balances[from];\n        require(bal >= amount, \"INSUFFICIENT_BAL\");\n        unchecked { _balances[from] = bal - amount; }\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address owner_, address spender, uint256 amount) internal {\n        require(spender != address(0), \"ZERO_SPENDER\");\n        _allowances[owner_][spender] = amount;\n        emit Approval(owner_, spender, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"ZERO_TO\");\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        uint256 bal = _balances[from];\n        require(bal >= amount, \"INSUFFICIENT_BAL\");\n        unchecked { _balances[from] = bal - amount; }\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n\n"
      }
    }
  }
}